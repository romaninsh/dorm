<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - DORM - The Dry ORM</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DORM - The Dry ORM</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>DORM is an <strong>opinionated business entity framework</strong> for Rust, designed to simplify and
enhance the development of business applications by providing robust, maintainable, and
efficient tools for handling complex business logic and database interactions. It
leverages Rust's type safety and performance to offer a cost-effective and enjoyable
development experience</p>
<h2 id="purpose-and-opinionated-design"><a class="header" href="#purpose-and-opinionated-design">Purpose and Opinionated Design</a></h2>
<p>DORM was created with the purpose of transforming how business applications are developed
in Rust. By emphasizing structure, consistency, and best practices, DORM serves as not
just a toolkit but a comprehensive guide for building enterprise-level applications.</p>
<p>As an opinionated business entity framework, DORM prescribes specific methods and patterns
for handling data and business logic. This approach is chosen to ensure that applications
are not only performant and safe but also straightforward to maintain and scale.</p>
<p>Unlike more generic libraries or crates (like Actix or Diesel) DORM focuses on guiding
developers to consistency and best practices in application architecture. DORM provides
an overarching structure that encapsulates more than just individual components, ensuring
that business logic and data management are integrated into a cohesive framework designed
for enterprise applications.</p>
<h2 id="architectural-separation-of-concern"><a class="header" href="#architectural-separation-of-concern">Architectural Separation of Concern</a></h2>
<p>One of the fundamental principles of DORM is the separation of the data persistence layer
from the business logic. This separation is crucial for several reasons:</p>
<ul>
<li>
<p><strong>Flexibility in Data Management</strong> - DORM abstracts the data layer through its robust DataSet
and Query interfaces, allowing business logic to remain agnostic of the underlying database
technologies. This abstraction makes it possible to switch underlying databases or adapt to
different data storage solutions without rewriting business logic.</p>
</li>
<li>
<p><strong>Remote Data Handling</strong> - Acknowledging the trend towards distributed systems, DORM is designed
to manage data that is often stored remotely and accessed over networks (SQL, NoSQL, GraphQL or
RestAPI). This design consideration ensures that applications built with DORM can efficiently handle
data operations across varied environments and scale gracefully as demand increases.</p>
</li>
<li>
<p><strong>Efficiency in Data Operations</strong> - Unlike traditional ORMs, which manage data by frequently
fetching and storing individual records, DORM optimizes efficiency by maintaining data remotely and
using complex queries to handle or aggregate data directly in the database. This approach reduces
the number of database interactions, minimizes data transfer overhead, and enhances overall
performance by leveraging the database's capabilities to execute operations more effectively.</p>
</li>
<li>
<p><strong>Type Safety and Productivity</strong> - DORM capitalizes on the strengths of Rust’s robust type system,
enhancing code safety and developer productivity by enforcing type safety across business entities,
relationships, conditions, and expressions. This integration ensures higher code reliability and
facilitates faster development through precise type checks.</p>
</li>
<li>
<p><strong>Do not disturb the Business code</strong> - DORM excels in abstracting away the complexities of
the underlying data structures, ensuring that business logic remains stable and unaffected by
changes in the database schema. For instance, if the structure of a database is refactored (split
up table, or endpoint, introduction of cache or switch between database engines)—DORM's
abstraction layers ensure that these changes do not disrupt the existing business logic. This
approach not only minimizes disruptions caused by backend modifications but also introduces new
ways to perform business logic tests through unit-testing.</p>
</li>
</ul>
<h2 id="improving-the-learning-curve-with-dorm"><a class="header" href="#improving-the-learning-curve-with-dorm">Improving the Learning Curve with DORM</a></h2>
<p>DORM solves the challenge of developer learning curve by introducing a structured pattern for
defining business entities using powerful Rust generics. This is a perfect way how your project
structure can appear simple and familiar to developers from OOP backgrounds like Java or C#:</p>
<ul>
<li>
<p><strong>Business Entity Object</strong> - Rust has no Objects, but DORM gives a very similar experience
by leveraging traits and generics. This allows business entities to have the single interface
to persistence functions (deleting or updating records), typical logic extensions (soft-delete
and data normalization) and custom developer-defined abstractions (such as order fullfilment)</p>
</li>
<li>
<p><strong>Avoiding borrowing and lifetimes</strong> - Business entities are owned, clonable and can be
easily shared across your code. They can be further mutated (such as adding more conditions)
or yield related entities (such as a product having many orders). Rust syntax for manipulating
entities is simple and easy to understand.</p>
</li>
<li>
<p><strong>Hydrating</strong> - DORM allows you to easily hydrate (or fetch) the data. Business entities are
defined as sets of remotely stored records. It is easy to iterate, filter or map remote records.
DORM also allows use of expressions if persistence layer allows subqueries.</p>
</li>
</ul>
<h2 id="concepts-of-dorm"><a class="header" href="#concepts-of-dorm">Concepts of DORM</a></h2>
<p>DORM framework relies on concepts that work together and build upon eachother:</p>
<ol>
<li>DataSet - like a Map, but Rows are stored remotely and only fetched when needed.</li>
<li>Expressions - recursive template engine for building SQL.</li>
<li>Query - a dynamic object representing SQL query.</li>
<li>DataSources - an implementation trait for persistence layer.</li>
<li>Table - DataSet with consistent columns, condition, joins and other features of SQL table.</li>
<li>Field - representing columns or arbitrary expressions in a Table.</li>
<li>Busines Entity - a record for a specific DataSet (or Table), such as Product, Order or Client.</li>
<li>CRUD operations - insert, update and delete records in DataSet through hydration.</li>
<li>Reference - ability for DataSet to return related DataSet (get client emails with active orders for unavailable stock items)</li>
<li>Joins - combining two Tables into a single Table without hydration.</li>
<li>Associated expression - Expression for specific DataSource created by operation on DataSet (sum of all unpaid invoices)</li>
<li>Subqueries - Field for a Table represented through Associated expression on a Referenced DataSet.</li>
<li>Aggregation - Creating new table from subqueries over some other DataSet.</li>
<li>Associated record - Business Entity for a specific DataSet, that can be modified and saved back.</li>
</ol>
<p>Depending on your use pattern, you would be using several of the above concepts. The rest of this
book will focus on one concept at a time and will discuss it in depth.</p>
<p>The base use pattern of DORM, however would be primarily around Business Entities, Tables and Fields only.</p>
<h2 id="simple-example"><a class="header" href="#simple-example">Simple Example</a></h2>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dorm::prelude::*;

let clients = Table::new("client", postgres.clone())
    .add_field("name")
    .add_id_field("id")
    .add_field("active")

let active_clients = clients.add_condition(clients.get_field("active")?.eq(true));

for client in active_clients.get().await? {
    println!("{}", client["name"]?);
}
<span class="boring">}</span></code></pre></pre>
<p>This example relies on concepts of "Table", "Field" to create <code>clients</code> DataSet.
In order to target only <code>active_clients</code>, we make use of Conditions (which is a type
of Expression) and Field. Finally when fetching data we hydrate into serde_json::Map.</p>
<h2 id="same-example-with-business-entities"><a class="header" href="#same-example-with-business-entities">Same example with Business Entities</a></h2>
<p>Your application is likely to use consistent set of tables and columns. Those can
be defined once and reused through a concept of Business Entities. Lets look how
your code would change with introduction of Business Entity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use dorm::prelude::*;
use crate::business_entities::Client;

let clients = Client::table();

let active_clients = clients.only_active();

for client in active_clients.get().await? {
    println!("{}", client.name);
}
<span class="boring">}</span></code></pre></pre>
<p>Defining <code>clients</code> now is much simpler. The full set of fields is not needed for our
operation of fetching active clients. We can also define a method <code>only_active()</code>
in a business entity crate, so that it would be easy to reuse it across your code.</p>
<p>Finally business entities hydrate into a struct, giving you more type safety.</p>
<h2 id="real-life-example"><a class="header" href="#real-life-example">Real-life Example</a></h2>
<p>In this book, we will be using a fictional database for your typical Bakery business.
Primarily we will be using <code>product</code>, <code>inventory</code>, <code>order</code> and <code>client</code> tables. The
examples will rely on those business entities and focus on demonstrating other
capabilities of DORM:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn notify_clients_of_low_stock() -&gt; Result&lt;()&gt; {
    let products = Product::table_with_inventory();
    let products = products.with_condition(products.stock().eq(0));

    let clients = products
        .ref_order()
        .only_active()
        .ref_client();

    for client_comm in clients.get_email_comm().await? {
        client_comm.type = ClientCommType::LowStock;

        client_comm.save_into(ClientComm::queue()).await?;
    }
    Ok(())
}
<span class="boring">}</span></code></pre></pre>
<p>This is more "real-world" example implementing a scalable
implementation for a simple business process of sending emails to
clients that have active orders that cannot be fulfilled due to a low
stock.</p>
<p>The code is simple, safe and maintainable.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="1-table-and-fields.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="1-table-and-fields.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
