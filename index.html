<!DOCTYPE HTML>
<html lang="en" class="light" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Introduction - DORM - The Dry ORM</title>


        <!-- Custom HTML head -->
        
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->

    </head>
    <body class="sidebar-visible no-js">
    <div id="body-container">
        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('light')
            html.classList.add(theme);
            var body = document.querySelector('body');
            body.classList.remove('no-js')
            body.classList.add('js');
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var body = document.querySelector('body');
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            body.classList.remove('sidebar-visible');
            body.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div class="sidebar-scrollbox">
                <ol class="chapter"><li class="chapter-item expanded "><a href="introduction.html" class="active"><strong aria-hidden="true">1.</strong> Introduction</a></li><li><ol class="section"><li class="chapter-item expanded "><a href="1-table-and-fields.html"><strong aria-hidden="true">1.1.</strong> Table and Fields</a></li><li class="chapter-item expanded "><a href="2-expressions-and-queries.html"><strong aria-hidden="true">1.2.</strong> Expressions and Queries</a></li><li class="chapter-item expanded "><a href="3-fields-and-operations.html"><strong aria-hidden="true">1.3.</strong> Fields and Operations</a></li><li class="chapter-item expanded "><a href="4-conditions.html"><strong aria-hidden="true">1.4.</strong> Conditions</a></li><li class="chapter-item expanded "><a href="5-entity-model.html"><strong aria-hidden="true">1.5.</strong> Entity Model</a></li><li class="chapter-item expanded "><a href="6-joins.html"><strong aria-hidden="true">1.6.</strong> Joins</a></li><li class="chapter-item expanded "><a href="7-fetching-data.html"><strong aria-hidden="true">1.7.</strong> Fetching Data</a></li><li class="chapter-item expanded "><a href="8-struct-entities.html"><strong aria-hidden="true">1.8.</strong> Struct Entities</a></li><li class="chapter-item expanded "><a href="9-associated-entities.html"><strong aria-hidden="true">1.9.</strong> Associated Entities</a></li><li class="chapter-item expanded "><a href="10-references.html"><strong aria-hidden="true">1.10.</strong> References</a></li><li class="chapter-item expanded "><a href="11-subquery-expressions.html"><strong aria-hidden="true">1.11.</strong> Subquery Expressions</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <!-- Track and set sidebar scroll position -->
        <script>
            var sidebarScrollbox = document.querySelector('#sidebar .sidebar-scrollbox');
            sidebarScrollbox.addEventListener('click', function(e) {
                if (e.target.tagName === 'A') {
                    sessionStorage.setItem('sidebar-scroll', sidebarScrollbox.scrollTop);
                }
            }, { passive: true });
            var sidebarScrollTop = sessionStorage.getItem('sidebar-scroll');
            sessionStorage.removeItem('sidebar-scroll');
            if (sidebarScrollTop) {
                // preserve sidebar scroll position when navigating via links within sidebar
                sidebarScrollbox.scrollTop = sidebarScrollTop;
            } else {
                // scroll sidebar to current active section when navigating via "next/previous chapter" buttons
                var activeSection = document.querySelector('#sidebar .active');
                if (activeSection) {
                    activeSection.scrollIntoView({ block: 'center' });
                }
            }
        </script>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">DORM - The Dry ORM</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>DORM is a busines entity abstraction framework for Rust.</p>
<p>In Enterprise environment, software applications must be easy to maintain and change.
Typical Rust applications require significant effort to maintain and change the logic,
which makes Rust difficult to compete with languages such as Java, C# and Typescript.
Additionally, existing ORM libraries are rigid and do not allow you to decouple your
business logic from your database implementation detail.</p>
<p>DORM offers opinionated abstraction over SQL for a separation between your
physical database and business logic. Such decoupling allows you to change
either without affecting the other.</p>
<p>DORM also introduces great syntax sugar making your Rust code readable and
easy to understand. To achieve this, DORM comes with the following features:</p>
<ol>
<li>DataSet abstraction - like a Map, but Rows are stored remotely and only fetched when needed.</li>
<li>Expressions - use a power of SQL without writing SQL.</li>
<li>Query - a structured query-language aware object for any SQL statement.</li>
<li>DataSources - a way to abstract away the database implementation.</li>
<li>Table - your in-rust version of SQL table or a view</li>
<li>Field - representing columns or arbitrary expressions in a data set.</li>
<li>Entity modelin - a pattern for you to create your onw business entities.</li>
<li>CRUD operations - serde-compatible insert, update and delete operations.</li>
<li>Joins - combining tables into a single table.</li>
<li>Reference traversal - convert a set of records into a set of related records.</li>
<li>Subqueries - augment a table with expressions based on related tables.</li>
</ol>
<p>This book will guide you through the basics of DORM features and how to use them.</p>
<h2 id="example"><a class="header" href="#example">Example</a></h2>
<p>In this book, we will be using a fictional database for your typical Bakery business.
Primarily we will be using <code>product</code>, <code>inventory</code>, <code>order</code> and <code>client</code> tables.</p>
<p>With DORM, creating a function to notify clients about low stock, would look
like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn notify_clients_of_low_stock() -&gt; Result&lt;()&gt; {
    // Start with all our products and inventory
    let products = Products::table_with_inventory()
        .add_condition(Products::stock().eq(0));

    // Find clients who have product orders with low stock
    let clients = products
        .ref_order()
        .ref_client();

    // Drop clients into notification queue
    for client_comm in cilents.get_email_comm().await? {
        client_comm.type = ClientCommType::LowStock;

        client_comm.save_into(ClientComm::queue()).await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>// Create a set of products with low inventory
let out_of_stock_products = Products::new(postgres.clone())
.with_inventory()
.with_condition(Products::stock().lt(5));</p>
<p>// Traverse into suppliers of a products with low inventory
let suppliers = out_of_stock_products.ref_supplier();</p>
<p>// Execute query and iterate over the result
for supplier in suppliers.get().await.unwrap() {
order_more_stock(supplier.id());
}</p>
<pre><code>
The example above demonstrates multiple DORM features together, specifically:

- Abstracting entity definition into custom types such as Products and Suppliers
- Operating with abstract set of records, for example, out_of_stock_products is not fetched until much later
- Using type-safe conditions and expressions to filter the data
- Traversing relationships between sets of different entity types
- Finally - hydrating (or fetching) the data from the database (or remote API) for processing

To get you started with DORM, I will introduce you to all the concepts above one by one.

## The Query Languages

Traditionally ORM libraries simplify interaction with the database, reducing your powerful
SQL database to a simple key-value store. DORM takes a different approach. It takes advantage
of the SQL language to convert your Rust code into powerful SQL queries reducing number of
queries your application would need to execute.

DORM contains 3 layers of abstraction:

1.  Expressions - a parametric template system with recursive rendering capabilities.
2.  Query - a structured query-language aware object, that can be manipulated into any query.
3.  DataSets and Models - native Rust structures for interactign with single or multiple records.

Operations ond DataSets and Models are translated into SQL queries, which are then converted into
expressions.

To understand the basics of DORM, lets start with the fundamentals of expressions.

## Expressions

There are two base classes that Expressions are built around:

- Expression - a full ownership expression, which parameters have type of Value.
- ExpressionArc - a shared ownership expression, which parameters can be converted into Expression

Expressions are short-lived - they are created, rendered and discarded. ExpressionArc can remain
in memory for longer time and tie together various conditions, that may have shared ownership and
can be modified from other parts of your application, such as quick-search field.

Lets create an expression first:

```rust
use dorm::prelude::*;

let expr = expr!("concat({}, {})", "hello", "world");

println!("{}", expr.preview());
</code></pre>
<p>When expression is created, the template is stored separately from the arguments. This allows
you to use arbitrary types as arguments and also use nested queries too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!(
    "concat({}, {})",
    expr!("upper({})", "hello"),
    "world");

let expr2 = expr!("{} + {}", 2, 3);
<span class="boring">}</span></code></pre></pre>
<p>Method <code>preview()</code> would insert the arguments into the template, but when actually executing the query, the inserting would be done by the database driver instead.</p>
<p>JSON values are also natively supported. You may also implement <code>SqlChunk</code> trait for your own types
to allow them to be used in expressions too.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr = expr!("json = {}", json!({"name": "John", "age": 25}));
<span class="boring">}</span></code></pre></pre>
<p>For instance, you can use Operation for creating nested expressions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// (name = 'John' AND age &gt; 25)
let expr_and = Operation::and(vec![
    expr!("name = {}", "John"),
    expr!("age &gt; {}", 25)
]);

// concat('hello', 'world')
let fx_call = Operation::fx("concat", vec![
    expr!("hello"), expr!("world")
]);
<span class="boring">}</span></code></pre></pre>
<p>Now that you understand that expression is a building block, lets move on to Query.</p>
<h2 id="query"><a class="header" href="#query">Query</a></h2>
<p>Query is a way to dynamically build query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = Query::new()
    .set_table("users")
    .add_column_field("id")
    .add_column_field("email")
    .add_column("full_name", Some(expr!("concat(first_name, ' ', last_name)")))
    .add_where(expr!("age &gt; {}", 18))
    .add_order_by(expr!("full_name"))
<span class="boring">}</span></code></pre></pre>
<p>Note: Query (and several other structures) use standard rust builder pattern. Methods such
as add_column_field do not modify the object, but consume old object and retur new one.</p>
<p>Since Query is built with Expressions, which are recrursive by design, Queries can often be nested:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let roles = Query::new()
    .set_table("roles")
    .add_column_field("id")
    .add_column_field("role_name");

let outer_query = Query::new()
    .set_table("users")
    .add_with("roles", roles)
    .add_join(JoinQuery::new(
        JoinType::Inner,
        QuerySource::Table("roles".to_string(), None),
        QueryConditions::on().add_condition(expr!("users.role_id = roles.id")),
    ))
    .add_column_field("user_name")
    .add_column_field("roles.role_name");

let group = Query::new()
    .set_source(QuerySource::Query(outer_query))
    .add_column_field("role_name")
    .add_column_field("c", Operation::count("*"))
    .add_group_by("role_name");
<span class="boring">}</span></code></pre></pre>
<p>Query cannot execute itself, but a friendly DataSource can execute your query for you:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// client is a tokio-postgres client
let postgres = Postgres::new(Arc::new(Box::new(client)));

let result = postgres.select_rows(&amp;group).await.unwrap();
<span class="boring">}</span></code></pre></pre>
<p>You also have some flexibility here - Query (assumes SQL query) can be executed by Postgres DataSource or MySQL DataSource. However - there may also be GQuery (assumes GQL) that could
have unique implementaiton and it would need an appropriate DataSource to be executed.</p>
<p>Result will contain Vec<Value>, where Value will be a Value::Hashmap with keys being column names,
however for a different databases the Value could be different.</p>
<h2 id="datasets-and-models"><a class="header" href="#datasets-and-models">DataSets and Models</a></h2>
<p>The final layer of DORM is DataSets (and Models). DataSet represents a collection of records, while
a Model represents a single record.</p>
<p>Model is merely a simple rust Struct that implements Serialise and Deserialise traits, however
before you can use a Model you will need to declare a DataSet.</p>
<p>A simplest DataSet implementation is offered by Table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let products = Table::new("product", postgres.clone())
    .add_field("name")
    .add_field("description")
    .add_field("default_price")
<span class="boring">}</span></code></pre></pre>
<p>Note: current version of DORM does not support field types, however this is something that will
be added in later.</p>
<p>You can create clone of a table and tweak things up:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_products = products.clone()
    .add_condition(products.get_field("default_price")?.gt(100));
<span class="boring">}</span></code></pre></pre>
<p>Note: <code>products.get_field()</code> returns Option<Field> and can be used to build expressions. Because
the field you specify may not exist, you need to use <code>?</code> or <code>unwrap()</code>. Typically this is hidden
behind explicit methods of a custom struct.</p>
<p>Declaring Set Struct that corresponds to your business models is a great way to keep your code
clean and embedd some business logic:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub struct ProductSet {
    table: Table&lt;Postgres&gt;,
}
impl ProductSet {
    pub fn new(ds: Postgres) -&gt; Self {
        let table = Table::new("product", ds)
            .add_field("name")
            .add_field("description")
            .add_field("default_price");
        Self { table }
    }

    pub fn name(&amp;self) -&gt; &amp;Field {
        self.get_field("name").unwrap()
    }

    pub fn description(&amp;self) -&gt; &amp;Field {
        self.get_field("description").unwrap()
    }

    pub fn price(&amp;self) -&gt; &amp;Field {
        self.get_field("default_price").unwrap()
    }
}

pub struct ExpensiveProductSet {
    table: Table&lt;Postgres&gt;,
    price_threshold: Value::Integer,
}
impl ExpensiveProductSet {
    pub fn new(ds: Postgres, price_threshold: Value::Integer) -&gt; Self {
        let table = ProductSet::new(ds);
        let table = table
            .add_condition(table.default_price().gt(price_threshold));
        Self { table, price_threshold }
    }

    pub fn name(&amp;self) -&gt; &amp;Field {
        self.get_field("name").unwrap()
    }

    pub fn description(&amp;self) -&gt; &amp;Field {
        self.get_field("description").unwrap()
    }

    pub fn price(&amp;self) -&gt; &amp;Field {
        self.get_field("default_price").unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Note: at some point there should be a macro for unrolling field methods. Now that you
have defined your sets, you can easily work with them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let product_data = ProductSet::new(postgres.clone()).get().await.unwrap(); // Vec&lt;Value&gt;

let expensive_sum = ExpensiveProductSet::new(postgres.clone(),100)
    .sum("default_price")
    .await
    .unwrap(); // Value::Integer
<span class="boring">}</span></code></pre></pre>
<p>Finally, lets see how you can work with Models:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
pub struct Product {
    pub name: String,
    pub description: String,
    pub default_price: i32,
}

// Increase our expensive prices a little
ExpensiveProductSet::new(postgres.clone(),100)
    .map::&lt;Product&gt;(|p|p.default_price += 10)
    .await
    .unwrap();
<span class="boring">}</span></code></pre></pre>
<h2 id="relations-and-nested-models"><a class="header" href="#relations-and-nested-models">Relations and Nested Models</a></h2>
<p>The rest of DSQL is designed to help you map your business logic into models. For instance, you
may want to join several tables.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let basket_items = Table::new("basket_item", postgres.clone())
    .add_field("basket_id")
    .add_field("product_id")
    .add_field("quantity");

let basket_items = basket_items.add_join(ProductSet::new(postgres.clone()), "product_id", "id");
<span class="boring">}</span></code></pre></pre>
<p>You can also declare a relation between tables, rather then joining them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let basket_items = basket_items.has_one(
    "basket",
    Table::new("basket", postgres.clone()).add_field("date"),
    "basket_id",
    "id");
<span class="boring">}</span></code></pre></pre>
<p>Relationship does not have any impact on the generated query, but you can easily join it or
import fields.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let basket_items_subselect = basket_items
    .clone();

let basket_items_subselect = basket_items_subselect
    .add_field_expr("basket_date", basket_items_subselect.get_ref("basket")?.get_field("date")?)
// (select date from basket where basket.id = basket_id) as basket_date


let basket_items_join = basket_items
    .clone()
    .join_ref("basket");

let basket_items_join = basket_items_join
    .add_field_expr("basket_date", basket_items_join.get_join("basket")?.get_field("date")?)
// select basket.date as basket_date ... join basket on basket.id = basket_id
<span class="boring">}</span></code></pre></pre>
<p>Of course, once you wrap this into your custom Structs it becomes very beautiful and usable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BasketSet {
    table: Table&lt;Postgres&gt;,
}
impl BasketSet {
    pub fn new(ds: Postgres) -&gt; Self {
        let table = Table::new("basket", ds.clone())
            .add_field("date")
            .add_field_id("id")

            .has_many_cb("items", ||BasketItemSet::new(ds.clone()), "id", "basket_id")
            .add_field_cb("item_count", |t|t.ref_items().count())
            .add_field_cb("total", |t|t.ref_items().total_price())

            .add_cb_field("items", |t|t.ref_items())
        ;
        Self { table }
    }

    pub fn date(&amp;self) -&gt; &amp;Field {
        self.get_field("date").unwrap()
    }

    pub fn ref_items(&amp;self) -&gt; &amp;BasketItemSet {
        self.get_ref("items").unwrap()
    }

    pub fn items(&amp;self) -&gt; &amp;Field {
        self.ref_field("items").unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>and BasketItem:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct BasketItemSet {
    table: Table&lt;Postgres&gt;,
}
impl BasketItemSet {
    pub fn new(ds: Postgres) -&gt; Self {
        let table = Table::new("basket_item", ds.clone())
            .add_field("basket_id")
            .add_field("product_id")
            .add_field("quantity")
            .has_one_cb("basket", ||BasketSet::new(ds.clone()), "basket_id", "id")
            .has_one_cb("product", ||ProductSet::new(ds.clone()), "product_id", "id")

            // Add some optional fields
            .add_field_cb("basket_date", |t|t.ref_basket().date())
            .add_field_cb("default_price", |t|t.ref_product().default_price());
            .add_field_cb("total_price", |t|expr!(
                "{} * {}",
                t.quantity(),
                t.ref_product().default_price()
            ));
        Self { table }
    }

    pub fn basket_id(&amp;self) -&gt; &amp;Field {
        self.get_field("basket_id").unwrap()
    }

    pub fn product_id(&amp;self) -&gt; &amp;Field {
        self.get_field("product_id").unwrap()
    }

    pub fn quantity(&amp;self) -&gt; &amp;Field {
        self.get_field("quantity").unwrap()
    }
    pub fn total_price(&amp;self) -&gt; &amp;Field {
        self.get_field("total_price").unwrap()
    }

    pub fn ref_basket(&amp;self) -&gt; &amp;BasketSet {
        self.get_ref("basket").unwrap()
    }
    pub fn ref_product(&amp;self) -&gt; &amp;ProductSet {
        self.get_ref("product").unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, putting this all together, here is a beautiful example of using a single select to
calculate basket total price.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct Basket {
    item_count: i32,
    total: i32,
}

let my_basket = BasketSet::new(postgres.clone())
    .load(123)
    .into::&lt;Basket&gt;();

println!("Basket total: {} for {} items", my_basket.total_price, my_basket.item_count);
<span class="boring">}</span></code></pre></pre>
<h2 id="callback-joins-and-fields"><a class="header" href="#callback-joins-and-fields">Callback joins and fields</a></h2>
<p>In some cases, it makes sense to define your data set as a join between several tables. When you
are performing a join, it will collect the fields from both tables together (even if they already
have made some joins before).</p>
<p>In other cases, you would want a join to be optional. This can only be done with a LEFT join,
because any other join would affect number of columns returned with/without, but a LEFT join is
fully optional (as long as it matches into unique field).</p>
<p>You may also define some callback fields. This is good for some complex calculations, that you
wouldn't want to always happen like with the <code>total</code> and <code>item_count</code>.</p>
<p>DORM relies on the entity you pass in and it's deserialization details to infer which fields
you want to load:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct BasketDate {
    date: Date,
}

let my_basket_totals = BasketSet::new(postgres.clone())
    .with_id(123)
    .into::&lt;Basket&gt;();

let my_basket_date = BasketSet::new(postgres.clone())
    .with_id(123)
    .into::&lt;BasketDate&gt;();

<span class="boring">}</span></code></pre></pre>
<p>DataSet's into() function will determine which fields to load based on the type you are converting
into and the line above <code>with_id(123)</code> will infer the conditoin for loading the record. The code
above will generate 2 different queries - one for the totals and another for the date.</p>
<p>You may use as many different Structs as you want, there is no explicit bindings a transient
Model struct and the DataSet.</p>
<h2 id="nested-data-structures"><a class="header" href="#nested-data-structures">Nested data structures</a></h2>
<p><code>Table::add_field_cb</code> is a powerful tool to implement various kinds of fields. Field may define a
component of a Query , so when DORM is fetching Model data it would amend the query in anticipation,
alternatively it may result in another DataSet.</p>
<p>If DataSet is returned and it cannot be easily incorporated into the main query, DORM will perform
a separate query to fill in the result:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
struct BasketItems {
    date: Date,
    items: Vec&lt;BasketItem&gt;,
}

let my_basket_items = BasketSet::new(postgres.clone())
    .with_id(123)
    .into::&lt;BasketItems&gt;();
<span class="boring">}</span></code></pre></pre>
<p>In this case DORM will look into the <code>items</code> field, which is a callback and returns a
BasketItemSet. To fill in the Vec of basket items, additional query will be performed.</p>
<p>I want also to point out that the ref_items() will produce a secondary DataSet which
has the same DataSource.</p>
<p>If the DataSource is identical (cloned Arc of the same instance), that means we are
querying from the same database. But potentially the related DataSet could be linked
to a different DataSource.</p>
<p>This powerful abstraction makes it possible for a model to fetch data from multiple
physical databases, sources or APIs and combine them seamlessly.</p>
<h2 id="deleting-inserting-or-updating-items"><a class="header" href="#deleting-inserting-or-updating-items">Deleting, Inserting or Updating items</a></h2>
<p>So far we have been using a pretty bare-bones structures for a model. We are able to
load data into a struct. There are also ways to store data or delete rows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>BasketSet::new(postgres.clone())
    .with_id(123)
    .delete();

let new_basket_id = BasketSet::new(postgres.clone())
    .insert(my_basket_items);
<span class="boring">}</span></code></pre></pre>
<p>Methods <code>delete()</code> and <code>insert()</code> are can be added to your DataSet structure by a macro but
would look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl BasketSet {
    pub fn delete(&amp;self) {
        self.table.delete();
    }

    pub fn insert(&amp;self, item: impl Serialise) -&gt; Value {
        self.table.insert(item)
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Method <code>update()</code> is also there, but you must not forget to specify <code>with_id()</code> before using it,
otherwise it may affect multiple rows.</p>
<p>Note: See also a map() method that can be used to individually update multiple rows in a DataSet.
It is an expensive operation though, and will result in multiple updates.</p>
<p>This brings us to the need of having a primary key inside Models.</p>
<h2 id="persistence-aware-models"><a class="header" href="#persistence-aware-models">Persistence-aware Models</a></h2>
<p>A pesistence-awer model has a field refering to it's data source and a key. This makes
it easier for developer to load a record, modify and then store it back.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize)]
#[dorm_model]
pub struct Basket {
    // _ds: (DataSource, id)
    date: Date,
    item_count: Option&lt;i32&gt;,
    total: Option&lt;i32&gt;,
    items: Vec&lt;BasketItem&gt;,
}
<span class="boring">}</span></code></pre></pre>
<p>The <code>_ds</code> field is a special field that is used to store the DataSource, key and an initial
values of the record from the database.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_basket = Basket::load(BasketSet::new(ds.clone()), basket_id);

my_basket.date = Date::now();
my_basket.items.push(new_item);
let res = my_basket.save().await;
<span class="boring">}</span></code></pre></pre>
<p>When record is being saved back, only the fields you have modified will be updated. Additionally
the data can only be saved into the original DataSet, if you modify some essential fields, that
would make it go outside of the DataSet, this will result in an error:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let mut my_basket = Basket::load(BasketSet::new(ds.clone()), basket_id);

my_basket.shipped = true;
let res = my_basket.save_into(ShippedBasketSet::new(ds.clone())).await;
<span class="boring">}</span></code></pre></pre>
<p>This provides an essential guardrails for business application to avoid accidental logical errors.</p>
<h2 id="validation-and-sanitization"><a class="header" href="#validation-and-sanitization">Validation and Sanitization</a></h2>
<p>DORM does not offer a way for validation and sanitization of the data, but we recommend using
"nutype". Make sure that Serde is able to serialize your data structure and it will work fine
with DORM.</p>
<h2 id="making-dataset-static"><a class="header" href="#making-dataset-static">Making DataSet static</a></h2>
<p>You may see a problem with this code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_products = ProductSet::new(postgres.clone());
let expensive_products = expensive_products
    .add_condition(expensive_products.default_price().gt(100));
<span class="boring">}</span></code></pre></pre>
<p>The problem here is that add_condition takes <code>self</code> and this does not allow default_price() to
be borrow same object. This is a common problem with Rust. There are two ways to solve it.</p>
<p>First lets create condition in a temporary variable:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_products = ProductSet::new(postgres.clone());
let condition = expensive_products.default_price().gt(100);
let expensive_products = expensive_products
    .add_condition(condition);
<span class="boring">}</span></code></pre></pre>
<p>This works now fine, but code readability suffers a lot. Let me show you a better way, that
also speeds things up a little. This relies on Lazy Statics.</p>
<p>First, lets rebuild our ProductSet to be static:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>use std::sync::OnceLock;
use dorm::prelude::*;
use crate::postgres;

pub struct ProductSet {
    table: Table&lt;Postgres&gt;,
}

impl ProductSet {
    pub fn new() -&gt; Table&lt;Postgres&gt; {
        ProductSet::table().clone()
    }
    pub fn table() -&gt; &amp;'static Table&lt;Postgres&gt; {
        static TABLE: OnceLock&lt;Table&lt;Postgres&gt;&gt; = OnceLock::new();

        let table = TABLE.get_or_init(|| {
            Table::new("product", ds)
                .add_field("name")
                .add_field("description")
                .add_field("default_price");
        });

        table
    }
    pub fn name() -&gt; &amp;'static Field {
        ProductSet::table().get_field("name")
    }
    pub fn profit_margin() -&gt; &amp;'static Field {
        ProductSet::table().get_field("profit_margin")
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This implementation allows us to use ProducSet::name() without creating a new instance of
ProductSet. Next lets look how <code>fn main()</code> needs to change to provide postgres() connection:</p>
<pre><pre class="playground"><code class="language-rust">static POSTGRESS: OnceLock&lt;Postgres&gt; = OnceLock::new();

pub fn postgres() -&gt; Postgres {
    POSTGRESS
        .get()
        .expect("Postgres has not been initialized")
        .clone()
}

#[tokio::main]
async fn main() -&gt; Result&lt;()&gt; {
    let (client, connection) = tokio_postgres::connect("host=localhost dbname=postgres", NoTls)
        .await
        .context("Failed to connect to Postgres")?;

    tokio::spawn(async move {
        if let Err(e) = connection.await {
            eprintln!("connection error: {}", e);
        }
    });

    POSTGRESS
        .set(Postgres::new(Arc::new(Box::new(client))))
        .map_err(|_| anyhow::anyhow!("Failed to set Postgres instance"))?;
}</code></pre></pre>
<p>Finally - here is the code to create expensive product set once again:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_products = ProductSet::new().add_condition(ProductSet::default_price().gt(100));
<span class="boring">}</span></code></pre></pre>
<p>In fact you can move that into a method of a ProductSet:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl ProductSet {
    pub fn expensive() -&gt; Table&lt;Postgres&gt; {
        ProductSet::new().add_condition(ProductSet::default_price().gt(100))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>And your code will look like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expensive_products = ProductSet::expensive();
<span class="boring">}</span></code></pre></pre>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->

                            <a rel="next prefetch" href="1-table-and-fields.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

                    <a rel="next prefetch" href="1-table-and-fields.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
