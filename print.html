<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Vantage - The Dry ORM</title>
        <meta name="robots" content="noindex">


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Vantage - The Dry ORM</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="introduction"><a class="header" href="#introduction">Introduction</a></h1>
<p>Welcome to this Book on Vantage. Before we dive in, few assumptions:</p>
<ul>
<li>You have read the Introduction (README): <a href="https://github.com/romaninsh/vantage">https://github.com/romaninsh/vantage</a></li>
<li>You have cloned this repository, installed postgres and ran <code>0-intro</code> example.</li>
<li>You have interest in software development efficiency, safety and maintainability.</li>
<li>You have a bit of patience to get to the bottom of various components of Vantage as they are explained.</li>
<li>You might need some Rust experience, but I'll try to provide pointers and keep things simple.</li>
</ul>
<p>To get us on the same page, I'll need to go over a basic principles of enterprise software
requirements. Those won't apply to majority of Rust projects, but they are crucial
in commercial software development.</p>
<p>If you are familiar with the concepts (such as from work by Martin Fowler or Eric Evans),
you can skip this section.</p>
<h2 id="the-purpose-of-separation-of-concerns-and-complexity-abstraction"><a class="header" href="#the-purpose-of-separation-of-concerns-and-complexity-abstraction">The Purpose of separation of concerns and complexity abstraction</a></h2>
<p>Terms <code>concern separation</code> and <code>complexity abstraction</code> may be new to you, so I'm going to
look at the enterprise software more generally and also explain why languages such as Java,
C# and TypeScript are considered suitable, while Rust so far had no traction.</p>
<p>Majority of code for the enterprise is designed to "codify" business logic. As company
grows, business rules become more complex. When you open a bank account, you can choose
from few account types, but under the hood banks have hundreds of legacy account types.
A lot of hidden use-cases are needed for regulations or to support legacy systems.</p>
<p>In order to keep the code maintainable, old code must be pruned without affecting stability
of remaining code. Refactoring will always face resistance from product leads, who prefer
rolling out new features.</p>
<p>Companies prefer systems and frameworks which are more modular and easier to maintain.
In many cases, developers who originally wrote the code would no longer be with the company
and a lot of code is written by junior developers too.</p>
<h3 id="separation-of-concerns"><a class="header" href="#separation-of-concerns">Separation of Concerns</a></h3>
<p>Within your average product team (say - 20 developers) engineers who share the code, engineers
would find preference towards a certain sub-sections of your app. Some developers may prefer
working on the "order processing" while others will dive into "onboarding" flow. Those are
called areas of concern. The practice of separating those areas is called SoC - Separation of Concerns.</p>
<p>Rust generally relies on sub-crates to separate concerns, but there is one area, where
those areas intersect - and that is the "persistence layer".</p>
<h3 id="persistence-layer"><a class="header" href="#persistence-layer">Persistence layer</a></h3>
<p>As a business software is dealing with events - it needs to store it's state. Data needs
to persist between execution as well as propogate between containers. Business software
is state-less - when request comes in, the data is loaded, processed and stored back.</p>
<p>Request can come in from an API interface or event queue. Similarly data can be loaded/stored
from Database, APIs or Caches.</p>
<p>It is quite common that in order to process a single request the data would need to be loaded
and stored several times. Quite often external API would rely on intermediate APIs (middleware)
to achieve the task.</p>
<h3 id="idempotence"><a class="header" href="#idempotence">Idempotence</a></h3>
<p>Any request can fail. It can fail before any data is loaded or it can fail after the data
is processed and stored. Idempotence is a design pattern that ensures that any requset can
be retried by the caller. If the original request was successful, retry will also be successful,
but it will not cause any duplicates. This is called Retry safety.</p>
<p>To give you an example, request to send payment of $10 should not send a total of $20 if
it is "retried" due to communication issue inside a middleware.</p>
<h3 id="complexity-abstraction"><a class="header" href="#complexity-abstraction">Complexity Abstraction</a></h3>
<p>I have just went through some of the essential design principles of enterprise software systems.
If this is new to you, it may sound excessively complex.</p>
<p>Well, there is another trick we use in enterprise system and it is complexity abstraction.
An application can be built in layers, where each layer hides complexity.</p>
<p>In fact - when you were going through the <code>introduction</code> code, you have experienced
complexity abstraction first hand. You saw a simple and readable code, that was hiding
complexity through abstraction.</p>
<p>Rust is a complex language. Rust also does not provide any obvious way to implement
complexity abstraction.</p>
<p>Vantage has a ready-to-use way to do this in a consistent way - for instance SoftDelete extension
could provide <code>retry safety</code> for your delete operation.</p>
<h3 id="safety-and-performance"><a class="header" href="#safety-and-performance">Safety and Performance</a></h3>
<p>In my opinion, the most important aspect of enterprise software is safety. As humans
we all make mistakes. Quite often in a pursuit of performance, we sacrifice safety.</p>
<p>A seasoned developer may write a chunk of SQL code that quickly and efficiently
performs a complex aggregation. When junior developer comes in, they may introduce
a serious safety bug just by trying to tweak or replicate this complex SQL code.</p>
<p>Vantage offers a way to generate performant SQL code without sacrificing safety.</p>
<h3 id="impact-of-change"><a class="header" href="#impact-of-change">Impact of Change</a></h3>
<p>I've seen many projects which were stuck with a "legacy" data structure because
the codebase was riddled with hardcoded SQL queries. As business logic evolves,
it will require changes in the data structure.</p>
<p>Persistence abstraction of Vantage creates a layer for backward-compatibility. Operations
like splitting a table into two tables, moving columns between tables can be
handled without affecting change in business logic.</p>
<h3 id="testability"><a class="header" href="#testability">Testability</a></h3>
<p>It is crucial that business logic is testable. However - quite often the logic only
works when it has access to the data. The <code>integration tests</code> usually provides
test-data to a test-suite. Generally those are slow, they can't track code
coverage and they are hard to debug.</p>
<p>Vantage provides a way to test business logic through <code>unit tests</code>. By mocking your
data source, you can focus on the business logic. More importantly you can adopt
<code>test-driven development</code> and create standards for your code with test coverage.
Use of faster <code>unit-tests</code> also reduces your release cycle time - a metric that
companies are actively looking at.</p>
<h2 id="business-appps-with-vantage"><a class="header" href="#business-appps-with-vantage">Business Appps with Vantage</a></h2>
<p>Vantage addresses many of the challenges of enterprise software development.</p>
<p>Ready to learn how? The answers are coming.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="data-sets"><a class="header" href="#data-sets">Data Sets</a></h1>
<p>Traditional ORMs operate with records. If you have used SeaORM or Diesel - you need
to temporarily "un-learn" those. Vantage syntax may look similar, but it's very different to
the classic ORM pattern:</p>
<ol>
<li>
<p><strong>Vantage operates with Data Sets</strong>. A set can contain either a single record, no records or
a huge number of records. Set represents records in remote database (or API) and does
not store anything in memory.</p>
</li>
<li>
<p><strong>Vantage executes operations remotely</strong>. Changing multiple records in ORM involves
fetching all the records, modifying them and saving them back. Vantage prefers to
execute changes remotely, if underlying DataSource supports it.</p>
</li>
</ol>
<p>As a developer, you will always know when Vantage interacts with the database, because
those operations are async. Majority of Vantage operations - like traversing relationship,
calculating sub-queries - those are sync.</p>
<h2 id="sqltable-and-sqlquery"><a class="header" href="#sqltable-and-sqlquery"><code>sql::Table</code> and <code>sql::Query</code></a></h2>
<p>Vantage implements sql::Table and sql::Query - because we all love SQL. However you can
define other data sources - such as NoSQL, REST API, GraphQL, etc. Those extensions
do not need to be in same crate as Vantage. For the rest of this book I will only
focus on SQL as a predominant use-case.</p>
<p>Vantage is quite fluid in the way how you use <code>table</code> and <code>query</code>, you can use one to
compliment or create another, but they serve different purpose:</p>
<ol>
<li><code>sql::Table</code> has a structure - fields, joins and relations are defined dynamically.</li>
<li><code>sql::Query</code> on other hand is transient. It consists of smaller pieces which we call <code>sql::Chunk</code>.</li>
<li><code>sql::Table</code> can create and return <code>sql::Query</code> object from various methods</li>
</ol>
<p><code>sql::Chunk</code> trait that is implemented by <code>sql::Query</code> (or other arbitrary expressions)
acts as a <strong>glue</strong> betwene tables. For instance when you run traverse relations:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = Client::table().with_id(1);

let order_lines = client.ref_orders().ref_order_lines();
<span class="boring">}</span></code></pre></pre>
<ol>
<li>Vantage executes <code>field query</code> operation on a client set for field <code>id</code>.</li>
<li>Vantage creates <code>orders</code> table and adds <code>condition</code> on <code>client_id</code> field.</li>
<li>Vantage executes <code>field query</code> operation on <code>orders</code> table for field <code>id</code>.</li>
<li>Vantage creates <code>order_lines</code> table and adds <code>condition</code> on <code>order_id</code> field.</li>
</ol>
<p>Vantage weaves between <code>sql::Table</code> and <code>sql::Query</code> without reaching out to the
database behind a simple and intuitive code.</p>
<h2 id="readabledataset-and-writabledataset"><a class="header" href="#readabledataset-and-writabledataset">ReadableDataSet and WritableDataSet</a></h2>
<p>Vantage provides two traits: <code>ReadableDataSet</code> and <code>WritableDataSet</code>. As name
suggests - you can fetch records from Readable set. You can add, modify or delete
records in Writable set.</p>
<p>Vantage implements those traits:</p>
<ul>
<li><code>sql::Table</code> - implements both <code>ReadableDataSet</code> and <code>WritableDataSet</code>.</li>
<li><code>sql::Query</code> - implements <code>ReadableDataSet</code> only.</li>
</ul>
<h2 id="operating-with-data-sets"><a class="header" href="#operating-with-data-sets">Operating with Data sets</a></h2>
<p>At the very basic level - you can iterate through a readable data set.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let set_of_clients = Client::table();

for client in set_of_clients.get().await? {
    println!("{}", client.name);
}
<span class="boring">}</span></code></pre></pre>
<p>There are more ways to fetch data from <code>ReadableDataSet</code>:</p>
<ul>
<li><code>get</code> - returns all records in a Vec using default entity type</li>
<li><code>get_as</code> - return all records using a custom type</li>
<li><code>get_all_untyped</code> - return all records as a raw JSON object</li>
<li><code>get_some</code> and <code>get-some_as</code> - return only one record (or none)</li>
<li><code>get_row_untyped</code> - return single record as a raw JSON object</li>
<li><code>get_col_untyped</code> - return only a single column as a raw JSON values</li>
<li><code>get_one_untyped</code> - return first column of a first row as a raw JSON value</li>
</ul>
<p>In most cases you would use <code>get</code> and <code>get_some</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let client = Client::table().with_id(1);

let Some(client_data) = client.get_some().await? else { // fetch single record
    // handle error
};

for client_order in client.orders().get().await? { // fetch multiple records
    println!("{}", client_order.id);
}
<span class="boring">}</span></code></pre></pre>
<h2 id="creating-queries-from-tables"><a class="header" href="#creating-queries-from-tables">Creating Queries from Tables</a></h2>
<p>Sometimes you do not want result, but would prefer a query object instead. This gives you
a chance to tweak a query or use it elsewhere.</p>
<p>Vantage provides trait TableWithQueries that generates Query objects for you:</p>
<ul>
<li><code>get_empty_query</code> - returns a query with conditions and joins, but no fields</li>
<li><code>get_select_query</code> - like <code>get_empty_query</code> but adds all physical fields</li>
<li><code>get_select_query_for_field_names</code> - Provided with a slice of field names and expressions, only includes those into a query.</li>
<li><code>get_select_query_for_field</code> - Provided a query for individual field or
expression, which you have to pass through an argument.</li>
<li><code>get_select_query_for_fields</code> - Provided a query for multiple fields</li>
</ul>
<p>There are generally two things you can do with a query:</p>
<ol>
<li>Tweak and execute it</li>
<li>Use it as a <code>Chunk</code> elsewhere</li>
</ol>
<h3 id="tweaking-and-executing-a-query"><a class="header" href="#tweaking-and-executing-a-query">Tweaking and Executing a query</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vip_orders = Client::table().add_condition(Client::table().is_vip().eq(true)).ref_orders();

let query = vip_orders
    .get_select_query_for_field_names(&amp;["id", "client_id", "client"]) // excluding `total` here
    .with_column("total".to_string(), expr!("sum({})", vip_orders.total())) // add as aggregate
    .with_column("order_count".to_string(), expr!("count(*)"))
    .with_group_by(vip_orders.client_id());

let result = postgres().query_raw(&amp;query).await?;
<span class="boring">}</span></code></pre></pre>
<h3 id="using-a-query-as-a-chunk-elsewhere"><a class="header" href="#using-a-query-as-a-chunk-elsewhere">Using a query as a <code>Chunk</code> elsewhere</a></h3>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO - hypothetical example, not implemented in bakery_model

let product_123 = Product::table().with_code("PRD-123");
let john = Client::table().with_email("john@example.com");

let new_order = Order::table()
    .insert(Order {
        product: product_123,
        client: john,
        quantity: 1,
    }).await?;
<span class="boring">}</span></code></pre></pre>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// TODO: test
let john = Client::table().with_email("john@example.com");

let order = Order::table()
    .with_condition(Order::table().client_id().in(john.get_select_query_for_field(john.id())))
<span class="boring">}</span></code></pre></pre>
<p>Method <code>get_ref()</code> does exactly that, when you traverse relationships.</p>
<h2 id="conclusion"><a class="header" href="#conclusion">Conclusion</a></h2>
<p>DataSet is a powerful concept that sets aside Vantage from the usual ORM pattern.
<code>sql::Table</code> and <code>sql::Query</code> are the building blocks you interract with most
often in Vantage.</p>
<p>Understanding this would allow you to implement missing features (such as table grouping)
and eventually devleop extensions for your data model.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table"><a class="header" href="#table">Table</a></h1>
<p>I have introduced <code>sql::Table</code> in context of <a href="./1-dataset.html">Data Sets</a>, however before
diving deep into <code>Table</code> I must introduce <code>SqlTable</code> trait - a dyn-safe version of <code>Table</code>.</p>
<p><code>Table</code> type takes 2 generic parameters: <code>DataSource</code> and <code>Entity</code>. This is similar to
<code>Vec&lt;T&gt;</code> where <code>T</code> is a generic parameter. In other words <code>Table&lt;Postgres, User&gt;</code> is
not the same as <code>Table&lt;Postgres, Order&gt;</code>.</p>
<p><code>Table</code> also have methods returning <code>Self</code> for example <code>with_column</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = Table::new("users", postgres());
let users = users.with_column("id"); // users has same type
<span class="boring">}</span></code></pre></pre>
<p>Generic parameters and methods that return <code>Self</code> cannot be defined in dyn-safe traits.
(See <a href="https://doc.rust-lang.org/reference/items/traits.html#object-safety">https://doc.rust-lang.org/reference/items/traits.html#object-safety</a> for more info),
whihc is why I created <code>sql::SqlTable</code> trait.</p>
<p><code>Table</code> gives you convenience and you get unique type for your business entities,
but if you need to deal with generic <code>Table</code> you can use <code>SqlTable</code> trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn get_some_table() -&gt; Box&lt;dyn SqlTable&gt; {
    if some_condition() {
        Box::new(Table::new("users", postgres()))
    } else {
        Box::new(Table::new("orders", postgres()))
    }
}
<span class="boring">}</span></code></pre></pre>
<p>To convert <code>Box&lt;dyn SqlTable&gt;</code> back to <code>Table&lt;Postgres, User&gt;</code>, you can use downcasting:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user: Table&lt;Postgres, User&gt; = get_some_table().as_any_ref().downcast_ref().unwrap();
<span class="boring">}</span></code></pre></pre>
<p>If <code>some_condition()</code> was false and "orders" table was returned you get type missmatch and downcast
will fail. That's just how Rust type system works, so only downcast when you are 100% sure that you
are using the right type.</p>
<p>This works really for defining custom <code>ref_*</code> methods for entity traversal:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ref_orders(users: &amp;Table&lt;Postgres, User&gt;) -&gt; Table&lt;Postgres, Order&gt; {
    users.get_ref("orders").unwrap().as_any_ref().downcast_ref().unwrap()
    //       ^ returns Box&lt;dyn SqlTable&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>There is a more convenient method <code>get_ref_as</code>, that would downcast it for you:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn ref_orders(users: &amp;Table&lt;Postgres, User&gt;) -&gt; Table&lt;Postgres, Order&gt; {
    users.get_ref_as("orders").unwrap()
    //       ^ returns Table&lt;Postgres, _&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>Let me collect some facts about <code>Table</code> and <code>SqlTable</code>:</p>
<ol>
<li><code>sql::SqlTable</code> is a dyn-safe trait implementing most basic features of a table</li>
<li><code>sql::Table</code> is a struct implementing <code>SqlTable</code> trait and some additional features (such as ReadableDataSet)</li>
<li>When Table must refer to another table in a generic way, it will be using <code>dyn SqlTable</code></li>
<li><code>sql::Table</code> type relies on 2 generic parameters: <code>DataSource</code> and <code>Entity</code></li>
<li><code>DataSource</code> describes your SQL flavour and can affect how queries are built etc.</li>
<li><code>Entity</code> can be implemented by any struct.</li>
</ol>
<p>To reinforce your understanding of how this all works together, lets compare 3 examples.
First I define a function that generates a report for <code>Table&lt;Postgres, Order&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_order_report(orders: &amp;Table&lt;Postgres, Order&gt;) -&gt; Result&lt;String&gt; {
    ...
}

generate_order_report(Order::table()); // Table&lt;Postgres, Order&gt;
// generate_order_report(Client::table());
// does not compile ^
<span class="boring">}</span></code></pre></pre>
<p>I'd like to test my method using <code>MockDataSource</code> and therefore I want it to work with
any <code>DataSource</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>async fn generate_order_report&lt;D: DataSource&gt;(orders: Table&lt;D, Order&gt;) -&gt; Result&lt;String&gt; {
    ...
}

let orders = Order::mock_table(&amp;mock_orders);
generate_any_report(orders).await?;  // Table&lt;MockDataSource, Order&gt;

<span class="boring">}</span></code></pre></pre>
<p>What if my code should work with any entity, but I don't wish to deal with <code>SqlTable</code>?</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn generate_any_report&lt;D: DataSource, E: Entity&gt;(table: Table&lt;D, E&gt;) -&gt; Result&lt;String&gt; {
    ...
}

generate_any_report(Order::table()).await?;  // Table&lt;Postgres, Order&gt;
generate_any_report(Client::table()).await?; // Table&lt;Postgres, Client&gt;

let orders = Order::mock_table(&amp;mock_data);
generate_any_report(orders).await?;  // Table&lt;MockDataSource, Order&gt;
<span class="boring">}</span></code></pre></pre>
<p>(The nerdy explanation here is that Rust compiler will create 3 copies of <code>generate_any_report</code>
function for each <code>D</code> and <code>E</code> combinations you use in the code).</p>
<h2 id="creating"><a class="header" href="#creating">Creating</a></h2>
<p>A simplest way to create a table object would be Table::new:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = Table::new("users", postgres())
<span class="boring">}</span></code></pre></pre>
<p>The type of <code>users</code> variable shall be <code>Table&lt;Postgres, EmptyEntity&gt;</code>. If instead of <code>EmptyEntity</code>
you'd like to use <code>User</code> you can use <code>new_with_entity</code> method.</p>
<p><code>DataSource</code> type is inferred from the second argument to new() - return type of
<code>postgres()</code> function.</p>
<p>Lets look at how we can define our own Entity:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Clone, Debug, Serialize, Deserialize, Default)]
struct User {
    id: i64,
    name: String,
}
impl Entity for User {}

let users = Table::new_with_entity::&lt;User&gt;("users", postgres());
<span class="boring">}</span></code></pre></pre>
<p>Rust will infer type when it can, so:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>fn user_table() -&gt; Table&lt;Postgres, User&gt; {
    Table::new_with_entity("users", postgres())
}
<span class="boring">}</span></code></pre></pre>
<p>Finally, rather than implementing a stand-alone method like that, we can implement it on the <code>User</code>
struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    fn table() -&gt; Table&lt;Postgres, User&gt; {
        Table::new_with_entity("users", postgres())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Since table structure is the same throughout the application, lets add columns
into the table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl User {
    pub fn table() -&gt; Table&lt;Postgres, User&gt; {
        Table::new_with_entity("users", postgres())
            .with_column("id")
            .with_column("name")
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="implementing-custom-traits-for-the-entity"><a class="header" href="#implementing-custom-traits-for-the-entity">Implementing custom traits for the entity</a></h2>
<p>In Rust you can define an arbitrary trait and implement it on any type.
Lets define trait <code>UserTable</code> and implement it on <code>Table&lt;Postgres, User&gt;</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>trait UserTable: SqlTable {
    fn name(&amp;self) -&gt; Arc&lt;Column&gt; {
        self.get_column("name").unwrap()
    }
}
impl UserTable for Table&lt;Postgres, User&gt; {}
<span class="boring">}</span></code></pre></pre>
<p>Now we can call <code>name()</code> method on type <code>Table&lt;Postgres, User&gt;</code> to access <code>name</code> column more directly:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let user = User::table();
let name_column = user.name();
<span class="boring">}</span></code></pre></pre>
<p>We can also modify our <code>generate_order_report()</code> function into a custom trait:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>#![allow(async_fn_in_trait)]
<span class="boring">fn main() {
</span>pub trait OrderTableReports {
    async fn generate_report(&amp;self) -&gt; Result&lt;String&gt;;
}

// was: async fn generate_order_report&lt;D: DataSource&gt;(orders: Table&lt;D, Order&gt;) -&gt; Result&lt;String&gt;

impl&lt;D: DataSource&gt; OrderTableReports for Table&lt;D, Order&gt; {
    async fn generate_report(&amp;self) -&gt; Result&lt;String&gt; {
        ...
    }
}
<span class="boring">}</span></code></pre></pre>
<h2 id="conclusion-1"><a class="header" href="#conclusion-1">Conclusion</a></h2>
<p>I have explained about <code>sql::Table</code> struct and <code>SqlTable</code> trait and which of the two should be used.
Also I have explained how to create custom traits and extend <code>Table</code> for specific entity type.</p>
<p>In my next chapters I'll refer to <code>Table</code> but in most cases you should understand that most
features would also work with <code>SqlTable</code> trait.</p>
<p>This chapter was Rust-intensive, but you should now understand how entity types are used in Vantage.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="table-columns"><a class="header" href="#table-columns">Table Columns</a></h1>
<p><code>Table</code> allows you to define and reference columns. A <code>Column</code> is another struct in Vantage.
Using columns outside of table context is convenient, such as for defining an expression:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = Table::new("users", postgres())
    .with_column("id")
    .with_column("name")
    .with_column("surname")
    .with_expression("full_name", |t| {
        expr!(
            "concat_ws({}, {}, {})",
            " ",
            t.get_column("name").unwrap(),
            t.get_column("surname").unwrap()
        )
    });
<span class="boring">}</span></code></pre></pre>
<p>Columns can also be used in conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = users.get_column("name").unwrap().eq("John");
let john = user.with_condition(condition);
<span class="boring">}</span></code></pre></pre>
<p>When you use <code>user.get()</code>, with <code>User { name, surname, full_name }</code>, <code>Table</code> needs to
ensure query would include both columns and expression too. More broadly, lets talk about
what can be deserialised into a <code>User</code> entity fields:</p>
<h2 id="field-could-be"><a class="header" href="#field-could-be">Field could be:</a></h2>
<ol>
<li><strong>Column</strong> - There is a physical SQL column <code>name</code> and <code>surname</code>.</li>
<li><strong>Expression</strong> - No physical column, but <code>full_name</code> is defined through a SQL expression.</li>
<li><strong>Joined Columns</strong> - Table could be joined with another table, combining columns.</li>
<li><strong>Callback</strong> - Value is calculated after record is fetched using a callback.</li>
</ol>
<p>Lets dive into the following example scenario:</p>
<ol>
<li><code>users: Table&lt;Postgres, User&gt;</code> has a column <code>name</code> and <code>surname</code>, using table "user"</li>
<li>I added an expression <code>full_name</code> that combines <code>name</code> and <code>surname</code> columns</li>
<li>I also joined "user_address" table, that contains <code>street</code> and <code>city</code> columns</li>
<li>I also define callback for calculating <code>post_code</code> by fetching from external API or cache.</li>
</ol>
<p>After above operations the following is true:</p>
<ul>
<li><code>users</code> has 3 columns</li>
<li><code>users</code> has 1 expression</li>
<li><code>users</code> has 1 joined table, which has another 2 columns</li>
<li><code>users</code> has 1 callback</li>
<li><code>users</code> has 6 fields: <code>id</code>, <code>name</code>, <code>surname</code>, <code>full_name</code>, <code>user_address_street</code>, <code>user_address_city</code></li>
<li><code>users</code> can deserialise into <code>User</code> struct with 7 fields: <code>id</code>, <code>name</code>, <code>surname</code>, <code>full_name</code>, <code>user_address_street</code>,
<code>user_address_city</code> and <code>post_code</code></li>
</ul>
<h2 id="working-with-table-columns-sqltable"><a class="header" href="#working-with-table-columns-sqltable">Working with Table Columns: SqlTable</a></h2>
<p>Column operations are implemented in <code>TableWithColumns</code> trait:</p>
<ul>
<li><code>add_column</code> - adds a column to the table</li>
<li><code>columns</code> - returns all physical columns</li>
<li><code>add_id_column</code> and <code>add_title_column</code> - adds a column but also labels it</li>
<li><code>id</code> - return <code>id</code> column</li>
<li><code>title</code> - return <code>title</code> column</li>
<li><code>id_with_table_alias</code> - return <code>id</code> column with table alias</li>
<li><code>get_column</code> - return a column by name</li>
<li><code>get_column_with_table_alias</code> - return a column by name with table alias</li>
<li><code>search_for_field</code> - similar to <code>get_column</code> but will look for lazy expressions and columns from joined tables.</li>
</ul>
<h2 id="working-with-table-columns-tabled-e"><a class="header" href="#working-with-table-columns-tabled-e">Working with Table Columns: Table&lt;D, E&gt;</a></h2>
<p><code>Table&lt;D, E&gt;</code> implements some additional methods for convenience:</p>
<ul>
<li><code>with_column</code> - adds a column to the table and returns it</li>
<li><code>with_title_column</code> - adds a title column to the table and returns it</li>
<li><code>with_id_column</code> - adds an id column to the table and returns it</li>
</ul>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let users = Table::new("users", postgres())
    .with_id_column("id")
    .with_title_column("name")
    .with_column("role_name");
<span class="boring">}</span></code></pre></pre>
<h2 id="extending-entity-with-column-getters"><a class="header" href="#extending-entity-with-column-getters">Extending Entity with column getters</a></h2>
<p>it is common practice to define field getters like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>pub trait ClientTable: SqlTable {
    fn name(&amp;self) -&gt; Arc&lt;Column&gt; {
        self.get_column("name").unwrap()
    }
    fn contact_details(&amp;self) -&gt; Arc&lt;Column&gt; {
        self.get_column("contact_details").unwrap()
    }
    fn bakery_id(&amp;self) -&gt; Arc&lt;Column&gt; {
        self.get_column("bakery_id").unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>This makes it easier to reference columns:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>expr!(
    "concat_ws({}, {}, {})",
    " ",
    //t.get_column("name").unwrap(),
    //t.get_column("surname").unwrap()
    t.name(),
    t.surname()
)
<span class="boring">}</span></code></pre></pre>
<h2 id="conclusion-2"><a class="header" href="#conclusion-2">Conclusion</a></h2>
<p>Ability to specify columns not by name but through a dedicated method makes
use of Rust type system and avoids typos at compile time. Fields in a query
can be defined through different means.</p>
<p>Swapping Column into Expression allow you to restructure your field names
without changing the code, also you can bring columns from across the
entities, but for that we will need to learn more about Expressions</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions-and-queries"><a class="header" href="#expressions-and-queries">Expressions and Queries</a></h1>
<p>In Vantage, query is a dynamic representation of a SQL query. You already saw how <code>sql::Table</code> is
creating <code>sql::Query</code>, now it's time to learn how <code>sql::Query</code> works.</p>
<p>Query owes it's flexibility to <code>Expressions</code> or more specifically to a <code>Chunk</code> trait. Any type
implementing <code>Chunk</code> can be part of a Query. <code>Expression</code> is just a simplest implementation of
<code>Chunk</code> trait.</p>
<p>The main reason for using <code>Expression</code> is separation of SQL statements and its parameters. Treating
SQL as a string introduces a possibility for SQL injections:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let query = format!(
  "SELECT * FROM product WHERE name = \"{}\"",
  user_name
);
<span class="boring">}</span></code></pre></pre>
<p>What if <code>user_name</code> contains <code>"</code> character? Expression is able to handle this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expression = Expression::new(
    "SELECT * FROM product WHERE name = {}",
    vec![json!("DeLorian Doughnut")]);

writeln!(expression.preview());
<span class="boring">}</span></code></pre></pre>
<p>Expression holds <code>statement</code> and <code>parameters</code> separatelly. Here are some methods of <code>Expression</code>:</p>
<ul>
<li><code>expr!()</code> - macro for creating new expression</li>
<li><code>new()</code> - constructor, used by the macro</li>
<li><code>Expression::empty()</code> - an empty expression</li>
<li><code>sql()</code> - return SQL statement (without parameters)</li>
<li><code>sql_final()</code> - returns SQL but will replace {} placeholders with $1, $2 as requested by an underlying SQL access library</li>
<li><code>params()</code> - return array of parameters</li>
<li><code>preview()</code> - will insert parameters into the statement and show it for preview purposes. Do not use for executing queries!</li>
<li><code>split()</code> - returns statement and parameters as a tuple</li>
<li><code>from_vec()</code> - combines multiple expressions into one using delimeter (like concat_ws)</li>
</ul>
<h2 id="expr-macro"><a class="header" href="#expr-macro"><code>expr!()</code> macro</a></h2>
<p>Parameters in expressions can have of several types, like i64 or String or &amp;str:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expression = expr!("INSERT INTO user (name, age) VALUES ({}, {})", "John", 30);
<span class="boring">}</span></code></pre></pre>
<p>This macro relies on <code>serde_json::json!</code> macro to convert parameters to <code>serde_json::Value</code>.</p>
<h2 id="expressionarc"><a class="header" href="#expressionarc">ExpressionArc</a></h2>
<p><code>Expression</code> implements <code>Chunk</code> trait, however it can only hold static parameters. Sometimes
we want our expressions to be able to hold other <code>Chunk</code> types. This is where <code>ExpressionArc</code>
comes in:</p>
<p><code>ExpressionArc</code> is similar to <code>Expression</code> but can contain Arc&lt;Box<dyn Chunk>&gt; as a parameter.
It even has a similar macro:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expression = expr_arc!("INSERT INTO user (name, age) VALUES ({}, {})", "John", 30);
<span class="boring">}</span></code></pre></pre>
<p>Now, we can also pass nested expressions to <code>expr_arc!</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expression = expr_arc!("INSERT INTO {} (name, age) VALUES ({}, {})", expr!("user"), expr!("John"), 30);
<span class="boring">}</span></code></pre></pre>
<h2 id="overview-of-expressionarc-methods"><a class="header" href="#overview-of-expressionarc-methods">Overview of ExpressionArc methods:</a></h2>
<ul>
<li><code>from_vec()</code> - combines multiple <code>Chunk</code>s into single expression using a delimiter (like concat_ws)</li>
<li><code>fx()</code> - handy way to create a function call: <code>fx!("UPPER", vec!["Hello"])</code></li>
</ul>
<p>Just like <code>Expression</code>, <code>ExpressionArc</code> implements <code>Chunk</code>, so can be nested. This feature is crucial
for building queries.</p>
<h2 id="query-type"><a class="header" href="#query-type">Query type</a></h2>
<p>A <code>Query</code> will consists of many parts, each being a <code>Chunk</code>. When query needs to be rendered, it will
render all of its parts recursively:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// example from Query::render_delete()
Ok(expr_arc!(
    format!("DELETE FROM {}{{}}", table),
        self.where_conditions.render_chunk()
    ).render_chunk())
<span class="boring">}</span></code></pre></pre>
<p>Obviously you can extend this easily or even have your own version of <code>Query</code>. Generally it's not needed,
as <code>Query</code> is very flexible and diverse. It can also hold other queries recursively.</p>
<p>Locate <code>bakery_model/examples/3-query-builder.rs</code> for an example of a super-complex query syntax.</p>
<h3 id="query-overview"><a class="header" href="#query-overview">Query Overview:</a></h3>
<p>Let me establish a pattern first:</p>
<ul>
<li><code>set_table()</code> - sets table for a query</li>
<li><code>set_source()</code> - similar to <code>set_table()</code> but QuerySource can be a table, another query or an expression</li>
<li><code>with_table()</code> - similar to <code>set_table()</code> but returns a modified Self</li>
</ul>
<p>As with <code>Table</code> type earlier - <code>set_table()</code> adn <code>set_source()</code> are implemented as part of dyn-safe <code>SqlQuery</code> trait.
On other hand <code>with_table()</code> is only implemented by <code>Query</code> struct.</p>
<p>Here are some other methods:</p>
<ul>
<li><code>new()</code> - returns a blank query</li>
<li><code>set_distinct()</code>, <code>with_distinct()</code> - includes <code>DISTINCT</code> keyword into a query</li>
<li><code>set_type()</code>, <code>with_type()</code> - sets query type (INSERT, UPDATE, DELETE, SELECT)</li>
<li><code>add_with()</code>, <code>with_with()</code> - adds a WITH subquery to a query</li>
<li><code>add_field()</code>, <code>with_field()</code> - adds a field to a query</li>
<li><code>with_field_arc()</code> - accepts <code>Arc&lt;Box&lt;dyn Chunk&gt;&gt;</code> as a field</li>
<li><code>with_column_field()</code> - simplified way to add a table columns to a query</li>
<li><code>without_fields()</code> - removes all fields from a query</li>
<li><code>with_where_condition()</code>, <code>with_having_condition()</code> - adds a condition to a query.</li>
<li><code>with_condition()</code>, <code>with_condition_arc()</code> - accepts <code>impl Chunk</code> and <code>Arc&lt;Box&lt;dyn Chunk&gt;&gt;</code> as a condition</li>
<li><code>with_join()</code> - adds a join to a query</li>
<li><code>with_group_by()</code>, <code>add_group_by()</code> - adds a group by to a query</li>
<li><code>with_order_by()</code>, <code>add_order_by()</code> - adds an order by to a query</li>
<li><code>with_set_field()</code>, <code>set_field_value()</code> - sets a field value for INSERT, UPDATE or REPLACE queries</li>
</ul>
<p><code>Query</code> relies on several sub-types: <code>QuerySource</code>, <code>QueryConditions</code>, <code>JoinQuery</code> etc.</p>
<h2 id="how-query-uses-expressions-"><a class="header" href="#how-query-uses-expressions-">How Query uses Expressions ?</a></h2>
<p>Lets look at some examples, which combine Expressions and Query:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let expr1 = expr!("name = {}", "John");
let expr2 = expr!("age &gt; {}", 30);

let query = Query::new()
    .with_table("users", None)
    .with_column_field("id")
    .with_column_field("name")
    .with_condition(expr1)
    .with_condition(expr2);

writeln!(query.preview());

// renders into: SELECT id, name FROM users WHERE name = 'John' AND age &gt; 30
<span class="boring">}</span></code></pre></pre>
<p>Lets continue to build out and make <code>query</code> part of a bigger <code>query2</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// query is from example above
let query2 = Query::new()
    .with_table("orders", None)
    .with_condition(expr_arc!("user_id in {}",
        query
            .clone()
            .without_fields()
            .with_column_field("id")
    ));

writeln!(query2.preview());

// renders into: SELECT * FROM orders WHERE user_id in (SELECT id FROM users WHERE name = 'John' AND age &gt; 30)
<span class="boring">}</span></code></pre></pre>
<h2 id="summary"><a class="header" href="#summary">Summary</a></h2>
<p>Vantage's query system leverages <code>Expressions</code> and the <code>Chunk</code> trait to build dynamic, safe, and
composable SQL queries. <code>Expressions</code> separate SQL statements from parameters, preventing injection
risks, while <code>ExpressionArc</code> extends this flexibility by supporting nested expressions.</p>
<p><code>Queries</code> are constructed from multiple <code>Chunk</code>s, allowing complex operations like subqueries,
joins, and conditions to be rendered recursively.</p>
<p><code>Query</code> methods like <code>with_table</code>, <code>with_field</code>, and <code>with_condition</code> make query building very
simple and customizable, while macros like <code>expr!</code> and <code>expr_arc!</code> simplify additional ways to
extend queries.</p>
<p>Next, I'll explain how <code>Expressions</code> and <code>Query</code> can be part of <code>Table</code> field expressions.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="expressions-in-a-table"><a class="header" href="#expressions-in-a-table">Expressions in a Table</a></h1>
<p>We now know, that Query can accept expressions pretty much anywhere, but
what about <code>Table</code>?</p>
<h2 id="add_expression-and-with_expression"><a class="header" href="#add_expression-and-with_expression"><code>add_expression()</code> and <code>with_expression()</code></a></h2>
<p>Table treats expressions lazily. Unless the Entity you are using
has a field that matches expression field name, it will not be evaluated.</p>
<p>To define expression use:</p>
<ul>
<li><code>add_expression</code> - define a callback returning Expression for a field</li>
<li><code>with_expression</code> - just like <code>add_expression</code> but returns modifield Self</li>
</ul>
<p>Lets define a field that returns current time:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>table.with_expression("current_time", || expr!("now()"));
<span class="boring">}</span></code></pre></pre>
<p>In our introduction example, we came across a field: <code>total</code>:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>// lineitem.rs
table.with_expression("total", |t: &amp;Table&lt;Postgres, LineItem&gt;| {
    t.price().render_chunk().mul(t.quantity())
})
<span class="boring">}</span></code></pre></pre>
<h2 id="chunks-and-expressions"><a class="header" href="#chunks-and-expressions">Chunks and Expressions</a></h2>
<p>Any <code>Chunk</code> can be converted into <code>Expression</code> but executing <code>render_chunk()</code>. If
you call <code>render_chunk()</code> on a Query, it will flattern itself into a static <code>Expression</code> type.</p>
<p>a callback that <code>with_expression</code> accepts, is expected to return <code>Expression</code>, but you
can use various ways on how to build it.</p>
<p>For instance, we can get a query from related table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_many("line_items", "order_id", || Box::new(LineItem::table()))
.with_expression("total", |t| {
    let item = t.sub_line_items();
    item.sum(item.total()).render_chunk()
})

// you also need this:
pub trait OrderTable: SqlTable {}
impl OrderTable for Table&lt;Postgres, Order&gt; {
    fn sub_line_items(&amp;self) -&gt; Table&lt;Postgres, LineItem&gt; {
        self.get_subquery_as("line_items").unwrap()
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Relationship between entities is defined by <code>with_many</code> and <code>with_one</code> methods.
Traversing this relationship can be done by <code>get_ref()</code> and <code>get_subquery()</code> methods.</p>
<p>We have already explored <code>get_ref()</code> earlier, but how is <code>get_subquery()</code> different?</p>
<ul>
<li><code>get_ref()</code> - given a DataSet - return related DataSet: <code>SELECT * FROM line_items WHERE order_id IN (SELECT id FROM ord)</code></li>
<li><code>get_subquery()</code> - Will return Table with a condition linking to the current table: <code>SELECT * FROM line_items WHERE order_id = ord.id</code></li>
</ul>
<p><code>get_subquery()</code> only makes sense if you make it part of the <code>Order</code> table query. It's perfect for
us to aggregate sum of <code>total</code>s:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let item = t.sub_line_items();
item.sum(item.total()).render_chunk()
<span class="boring">}</span></code></pre></pre>
<p>Here <code>item</code> is of type <code>Table&lt;Postgres, LineItem&gt;</code> which means we can use <code>Table::sum()</code> and custom
method <code>Table&lt;Postgres, LineItem&gt;::total()</code>.</p>
<p>Method <code>sum</code> returns <code>Query</code> (impl <code>Chunk</code>) which we can convert into <code>Expression</code> using <code>render_chunk()</code>.</p>
<p>BTW - <code>sum</code> accepts <code>Chunk</code> as an argument, and in our case that is just fine, because <code>total()</code> returns
a chunk and not a Column.</p>
<h2 id="another-example"><a class="header" href="#another-example">Another Example</a></h2>
<p>As our last example, lets look at LineItem implementation of a <code>price</code> field. This filed is implemented
through expression again, as we don't have a physical column fro it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_one("client", "client_id", || Box::new(Client::table()))
.with_expression("price", |t| {
    let product = t.get_subquery_as::&lt;Product&gt;("product").unwrap();
    product.field_query(product.price()).render_chunk()
})
<span class="boring">}</span></code></pre></pre>
<p>I haven't defined method like <code>sub_line_items</code> before, so I'm using <code>get_subquery_as</code> directly.
There is also <code>get_subquery</code> but it returns Box<dyn SqlTable>. I want to use <code>product.price()</code> so
instead I'm using <code>get_subquery_as</code> and specifying entity type explicitly.</p>
<p>As far as Vantage is concerned, it sees <code>with_one</code> and <code>with_many</code> relationships equally. I need to
think about this though. If subquery could return multiple rows, I'd need to have them limited,
aggregated or wrapped into a string somehow (like using ExpressionArc::fx())</p>
<p>In this case I don't have to worry about that. I just need to query a single field (that happens to
be a column <code>price</code>).</p>
<h2 id="expressions-in-conditions"><a class="header" href="#expressions-in-conditions">Expressions in Conditions</a></h2>
<p>Previously I have used the following code:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let set_of_clients = Client::table();

let condition = set_of_clients.is_paying_client().eq(&amp;true);
let paying_clients = set_of_clients.with_condition(condition);
<span class="boring">}</span></code></pre></pre>
<p>Condition is a struct, that implements <code>Chunk</code> trait. You can probably guess that <code>Table</code>
will apply those <code>Condition</code>s into resulting Queries and that's it.</p>
<p>Condition consists of <code>field</code> , <code>operation</code> and <code>value</code>:</p>
<ul>
<li><code>field</code>: Can be a <code>Column</code>, <code>Expression</code>, another <code>Condition</code> or a <code>serde_json::Value</code></li>
<li><code>operation</code> is just a string</li>
<li><code>value</code> is a <code>Chunk</code></li>
</ul>
<p>The reason why we don't simply throw everything into <code>Expression</code> - our <code>Column</code> might need
to use an alias (and sometimes we change alias as we join tables)</p>
<h2 id="operations"><a class="header" href="#operations">Operations</a></h2>
<p><code>Operations</code> is another Trait that allows type to participate in SQL operations. Both <code>Column</code> and <code>Expression</code> and <code>Value</code>
implement <code>Operations</code>, this allows this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let condition = column.eq(&amp;"John")

// or

let condition = expr!("now()").lt(&amp;yesterday)
<span class="boring">}</span></code></pre></pre>
<p>Conditions created by the operation can be used in <code>with_condition()</code> method.</p>
<h2 id="conclusion-3"><a class="header" href="#conclusion-3">Conclusion</a></h2>
<p>In Vantage - expressions and operations create a powerful way to extend of high-level <code>Table</code> features
such as conditions and expression fields.</p>
<p>Functionality is composable of underlying components. If <code>Table</code> does not implement a feature you
like, you can easily build it using Expressions and Operations.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="joins"><a class="header" href="#joins">Joins</a></h1>
<p>Join can happen between two tables with one-to-some(one) relationship.</p>
<p>A good example for us is if we add a new table called <code>inventory</code> that
joins <code>product</code> table:</p>
<pre><code class="language-sql">CREATE TABLE inventory (
    product_id SERIAL PRIMARY KEY,
    stock INT DEFAULT NULL
);
</code></pre>
<p>In this case, inventory does not particularly useful ol its own,
so we can make it part of the Products type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Product {
    pub fn table_with_inventory() -&gt; Self {
        Product::table()
            .with_alias("p")
            .with_join(
                Table::new("inventory", postgres())
                    .with_alias("i")
                    .with_id_field("product_id")
                    .with_field("stock"),
                "id",
            )
        }
    }
}
<span class="boring">}</span></code></pre></pre>
<p>The beautiful syntax here is going to give you exactly
what you expect:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let prod_inv = model::Product::table_with_inventory();
writeln!(prod_inv.get_select_query().preview());

// renders into: SELECT p.id, p.name, i.stock FROM product p LEFT JOIN inventory i ON (p.id = i.product_id)
<span class="boring">}</span></code></pre></pre>
<p>How is that possible? Well, Vantage's "with_join" method will
consume the table object that you pass and will move its
fields into the original table. The joined table will be
wrapped into a Join object and will instruct query builder
to add join into your query.</p>
<p>There are ways to create different kind of joins too, but
api for that is not yet stable.</p>
<p>As you will see later, Vantage operates with joined tables
just as good as with a single table.</p>
<p>Now is probably a great time to look into Vantages capabilities
of operating with your entities.</p>
<p>So far we only used Table to create select queries, but
we can in fact hydrate our entities with data from the
database.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="fetching-data"><a class="header" href="#fetching-data">Fetching Data</a></h1>
<p>So far we were creating tables and were generating queries
from them, but wouldn't it be great if we could fetch data
directly from the table object?</p>
<p>If you recall - our table is already associated with DataSource,
but when we execute <code>get_select_query()</code> the resulting Query
is not associated with any DataSource.</p>
<p>There is a type called <code>AssociatedQuery</code> that can be produced
by a table object and it has some beautiful methods to
actually fetch data.</p>
<p>Lets explore:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let low_cal_products = model::LowCalProduct::table();

let count = low_cal_products.count().get_one().await?;
<span class="boring">}</span></code></pre></pre>
<p>Table::count() is a method that returns a query for counting
rows in a table. Because our LowCalProducts contains a
condition, this will return a count of rows that match
the condition.</p>
<p>You could use count().preview() still to confirm,
that Vantage won't attept to fetch all records and iterate
over them, but instead will use a SUM() function to count rows:</p>
<pre><code class="language-sql">SELECT COUNT(*) FROM "product" WHERE "calories" &lt;= 100
</code></pre>
<p>Calling <code>get_one</code> will instead allow us to fetch the value
directly into a variable. We do not know what type our query
would produce, so get_one() returns json::Value and you can
use "as_i64" to cast it into a numeric type:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let count = model::LowCalProduct::table()
    .count()
    .get_one()
    .await?
    .as_i64()?
<span class="boring">}</span></code></pre></pre>
<p>Previously I was using unwrap() and now I am using "?" to unwrap.
This is because previously our code was certain that a field
woudl exist, since we added it ourselves, but with .get_one()
we are not sure about the response. Perhaps query execution
would fail, so we need a proper error handling.</p>
<p>Lets explore another method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let total_calories = model::LowCalProduct::new()
    .sum(model::Product::calories())
    .get_one()
    .await?
    .as_i64()?
<span class="boring">}</span></code></pre></pre>
<p>Here we are passing a Column object to the sum() method.</p>
<p>Some of those methods will be useful for us later, but for now
lets look at the way to fetch data from a table:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for product in model::LowCalProduct::table().get_all_data().await? {
    println!("{} ({} kcal)", product["name"]?, product["calories"]?);
}
<span class="boring">}</span></code></pre></pre>
<p>Next we will look at how to use power of Deserialize trait
of your custom type.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="struct-entities"><a class="header" href="#struct-entities">Struct Entities</a></h1>
<p>So far we have defined our Product type without any fields.
Lets add some fields to it:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Clone)]
pub struct Product {
    id: Option&lt;i64&gt;,
    name: String,
    calories: i64,
}
<span class="boring">}</span></code></pre></pre>
<p>You can now use get<Product>() to fetch data from the database
much more conveniently:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>for product in model::LowCalProduct::table().get&lt;Product&gt;().await? {
    println!("{} ({} kcal)", product.name, product.calories);
}
<span class="boring">}</span></code></pre></pre>
<p>There is now your type safety. You also can see that we can
use any type that implements Serialize and Deserialize traits
in get() method.</p>
<p>However, now that we have implemented a struct for our entity,
we can start modifying our data. Check this code out:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::LowCalProduct::table().map&lt;Product&gt;(|product| async move {
    product.calorues += 1;
})().await?;
<span class="boring">}</span></code></pre></pre>
<p>This allows you to iterate over your data as you did before,
but map() will also store data back to the database. You
just need to remember to have <code>id</code> field in your struct. Here
is what happens:</p>
<ol>
<li>Vantage determines the type of your struct (Product)</li>
<li>Vantage will fetch row from a query that includes your condition</li>
<li>Vantage will deserialize the row into your struct</li>
<li>Vantage will call your closure</li>
<li>Vantage will serialize your struct back to a row</li>
<li>Vantage will replace row in the database with the new values</li>
</ol>
<p>The map() method does not know if you have changed struct, so
it will always try to execute "REPLACE" query and based on
your unique id field, it should rewrite the row.</p>
<p>You can also use insert() method on your table to add a new
row to the database:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::Product::table().insert(Product {
    id: None,
    name: "New Product".to_string(),
    calories: 100,
})
.await?;
<span class="boring">}</span></code></pre></pre>
<p>Deleting is also possible, but you need to be careful. delete_all()
method will remove all rows.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::LowCalProduct::table().delete_all().await?;
<span class="boring">}</span></code></pre></pre>
<p>If you want to delete a specific row, you can set a condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::Product::table().with_id(1).delete_all();
<span class="boring">}</span></code></pre></pre>
<p>Although a more convenient method delete() exists too:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::Product::table().delete(1).await?;
<span class="boring">}</span></code></pre></pre>
<p>I should probably mention, that delete() method will not
affect rows in a table, which do not match the condition:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>model::LowCalProduct::table().delete(4).await?;
<span class="boring">}</span></code></pre></pre>
<p>Here a row with id=4 will only be deleted if calories is
less than 100 for this row.</p>
<p>This will be useful for us later.</p>
<p>Next I want to tell you about associated entities.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="associated-entities"><a class="header" href="#associated-entities">Associated Entities</a></h1>
<p>Do you remember how we used Query type only to discover that
there is also AssociatedQuery type?</p>
<p>Well, in the last chapter we used our custom entity type
Product and now it turns out you can have an associated
entity type too.</p>
<p>AssociatedEntity<T> is the way how your entity can remain
linked to the Table object. To save you from headache of
object lifetimes, it will actually contain a clone of a
table as well as ID field. Therefore your type will
no longer need an "id" field.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[derive(Serialize, Deserialize, Clone)]
pub struct Product {
    name: String,
    calories: i64,
}
<span class="boring">}</span></code></pre></pre>
<p>Now when we deal with associated entities, we load() and save()
them:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let product = model::Product::table().load&lt;Product&gt;(4).await?;

product.calories = 56;
product.save().await?;
<span class="boring">}</span></code></pre></pre>
<p>AssociatedEntity derefs itself so that you can still access
the fields. Additionally the following methods are added:</p>
<ul>
<li>reload() - reload entity from the database</li>
<li>id() - return id of the entity</li>
<li>delete() - delete the entity from the database</li>
<li>save() - saves the entity to the database</li>
<li>save_into() - saves entity into a different table</li>
</ul>
<p>Here is example:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>if let Some(product) = model::LowCalProduct::table().load_any::&lt;Product&gt;().await? {
    writeln!("Low-cal Product {} has {} calories", product.name, product.calories);
    product.calories += 100; // no londer LowCalProduct

    // product.save().await?; // will Err because of condition
    product.save_into(model::Product::table()).await?;
}
<span class="boring">}</span></code></pre></pre>
<p>It should no longer be a surprise to you that you can do the exactly same
stuff with a table which relies on Join:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>struct ProductInventory {
    name: String,
    stock: i64,
}

if let Some(product) = model::Product::with_inventory().load::&lt;ProductInventory&gt;(4).await? {
    writeln!("Product {} has {} items in stock", product.name, product.stock);
    if product.stock &gt; 0 {
        product.stock -= 1;
        product.save().await?;
    } else {
        product.delete().await?;
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Vantage will automatically understand, which fields you have changed (stock)
and will only update those fields. Vantage will also delete the row from
both "product" and "inventory" tables if stock is 0.</p>
<p>Your code remains intuitive, while Vantage takes care of the rest, but
lets make the code even better:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span>
<span class="boring">fn main() {
</span>impl AssociatedEntity&lt;ProductInventory&gt; {
    pub async fn sell(self, qty: i64) -&gt; Result&lt;()&gt; {
        if qty &gt; self.stock {
            return Err(anyhow::anyhow!("Not enough items in stock"));
        }
        self.stock -= qty;
        if self.stock == 0 {
            self.delete().await?;
        } else {
            self.save().await?;
        }
        Ok(())
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Now you can use your method like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let product = model::Product::with_inventory().load::&lt;ProductInventory&gt;(4).await?;
product.sell(10).await?;
<span class="boring">}</span></code></pre></pre>
<p>Rust never looked so good!</p>
<p>But hey, that's not all. Vantage also supports associations between two tables.
Keep reading!</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="references"><a class="header" href="#references">References</a></h1>
<p>Vantage allows you to connect tables together. Lets create two new tables
in addition to "Product" that we have already:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Order {
    product: Product,
    client: Client,
}

struct Client {
    name: String,
    contact_details: String,
}
<span class="boring">}</span></code></pre></pre>
<p>The definition of the tables would be just like in chapter 5-Entity Model, however
we will use "has_one" and "has_many" methods:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>impl Product {
    pub fn static_table() -&gt; &amp;'static Table&lt;Postgres&gt; {
        static TABLE: OnceLock&lt;Table&lt;Postgres&gt;&gt; = OnceLock::new();

        TABLE.get_or_init(|| {
            Table::new("product", postgres())
                .with_id_field("id")
                .with_field("name")
                .has_many("orders", "product_id", || Order::table())
        })
    }
}


impl Order {
    pub fn static_table() -&gt; &amp;'static Table&lt;Postgres&gt; {
        static TABLE: OnceLock&lt;Table&lt;Postgres&gt;&gt; = OnceLock::new();

        TABLE.get_or_init(|| {
            Table::new("order", postgres())
                .with_id_field("id")
                .with_field("name")
                .has_one("client", "client_id", || Client::table())
                .has_one("product", "product_id", || Product::table())
        })
    }
}

impl Client {
    pub fn static_table() -&gt; &amp;'static Table&lt;Postgres&gt; {
        static TABLE: OnceLock&lt;Table&lt;Postgres&gt;&gt; = OnceLock::new();

        TABLE.get_or_init(|| {
            Table::new("client", postgres())
                .with_id_field("id")
                .with_field("name")
                .with_field("contact_details")
                .has_many("orders", "client_id", || Order::table())
        })
    }
}
<span class="boring">}</span></code></pre></pre>
<p>Given one Table, Vantage lets you traverse relationships between tables.
Lets say we want to see how many orders does product with id=4 have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let product = model::Product::table().with_id(4);

let orders_count = product.get_ref("orders").unwrap().count().get_one().await?;
<span class="boring">}</span></code></pre></pre>
<p>Here is what happens under the hood:</p>
<ol>
<li>A query is generated for the Product where id=4</li>
<li>product query is used as a condition for a order query</li>
<li>order query is executed for counting rows</li>
</ol>
<pre><code class="language-sql">SELECT COUNT(*) FROM order WHERE (product_id = in (SELECT id FROM product WHERE (id = 4)));
</code></pre>
<p>This query may seem a bit redundant, but lets see how many LowCalProduct
orders we have:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let product = model::LowCalProduct::table();

let low_cal_orders = product.get_ref("orders").unwrap().count().get_one().await?;
<span class="boring">}</span></code></pre></pre>
<p>Resulting query now looks like this:</p>
<pre><code class="language-sql">SELECT COUNT(*) FROM order WHERE (product_id IN (SELECT id FROM product WHERE (calories &lt; 100)));
</code></pre>
<p>In Vantage relationship traversal is always converting one "set" into another "set".</p>
<p>In fact - if you want to calculate how many clients have placed orders for
Low Calory Products, you can do it like this:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let low_cal_products = model::LowCalProduct::table();
let clients_on_diet = low_cal_products
    .get_ref("orders")
    .unwrap()
    .get_ref("client")
    .unwrap()
    .count()
    .get_one()
    .await?;
<span class="boring">}</span></code></pre></pre>
<p>But lets not stop here. Suppose you wanted to send all clients who are
on a diet some email about a new product:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let low_cal_products = model::LowCalProduct::table();
let clients_on_diet = low_cal_products
    .get_ref("orders")
    .unwrap()
    .get_ref("client")
    .unwrap();

for client in clients_on_diet.get&lt;Client&gt;().await? {
    client.send_email("New low carb product is out!").await?;
}
<span class="boring">}</span></code></pre></pre>
<p>Imagine all the other things you could do. Yet once again,
Vantage has more surprises for you.</p>
<p>We have learned about expressions before, right? Well, expressions
can be built from subqueries.</p>
<div style="break-before: page; page-break-before: always;"></div><h1 id="subquery-expressions"><a class="header" href="#subquery-expressions">Subquery Expressions</a></h1>
<p>Once we have used "has_one" and "has_many" methods, we can now
add some expressions as well.</p>
<p>I'll start by extending our "Client::table()" with "total_orders" field.
Place that inside static_table() method:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>Table::new("client", postgres())
    .with_id_field("id")
    .with_field("name")
    .with_field("contact_details")
    .has_many("orders", "client_id", || Order::table())
    .with_expression("total_orders", move |t| {
        t.get_ref_related("orders").unwrap().count()
    })
<span class="boring">}</span></code></pre></pre>
<p>What happens here then?</p>
<ol>
<li>A query is generated for the Client</li>
<li>If "total_orders" field is requested, a callback is called</li>
<li>The callback is passed a Table object ("client"), which has a reference to the "orders" table</li>
<li>get_ref_related() is similar to get_ref(), but is suitable for subquery expressions</li>
<li>get_ref_related() returns a Table object</li>
<li>count() is called on the Table object, producting a SqlChunk object</li>
<li>The SqlChunk object is is aliased into "total_orders" field inside Query</li>
<li>Query is executed</li>
</ol>
<p>Lets also modify "Client" struct:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>struct Client {
    name: String,
    contact_details: String,
    total_orders: Option&lt;i64&gt;
}
<span class="boring">}</span></code></pre></pre>
<p>Now that we have know how many orders clients have placed, we can use it
as a condition.</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let vip_clients = clients.with_condition(clients.field("total_orders").gt(4));
<span class="boring">}</span></code></pre></pre>
<p>Lets also calculate how many low_cal_orders clients have placed:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>.with_expression("low_cal_orders", move |t| {
    t
        .get_ref_related("orders")
        .with_condition(t.get_filed("calories").unwrap().lt(100))
        .unwrap()
        .count()
})
.with_expression("high_cal_orders", move |t| {
    t
        .get_ref_related("orders")
        .with_condition(t
            .get_field("calories")
            .unwrap()
            .gt(100)
            .or(t.get_filed("calories").unwrap().eq(100))
        )
        .unwrap()
        .count()
})
<span class="boring">}</span></code></pre></pre>
<p>We just casually added 2 more expressions to our Client table. Those
normally won't be queried unless needed. However, we can use them
to calculate conditions:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>let diet_clients = clients
    .with_condition(clients
        .field("low_cal_orders")
        .gt(clients.field("high_cal_orders"))
    );
<span class="boring">}</span></code></pre></pre>
<p>Finally to clean things up a bit, we can move some of this logic
into our <code>model/*.rs</code> files.</p>
<p>Overall, you are now familiar with the basics of Vantage and can start
building business model abstractions for your application.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->


                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">

            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->

        <script>
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>

    </div>
    </body>
</html>
